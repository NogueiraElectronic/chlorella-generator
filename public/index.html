const express = require('express');
const fs = require('fs');
const path = require('path');
const app = express();

// Configuraci√≥n b√°sica
app.use(express.json({ limit: '10mb' }));
app.use(express.static('public'));

// Logging b√°sico
app.use((req, res, next) => {
    console.log(`${req.method} ${req.path} - ${new Date().toISOString()}`);
    next();
});

// Crear directorio de datasets
const datasetsDir = path.join(__dirname, 'generated_datasets');
if (!fs.existsSync(datasetsDir)) {
    fs.mkdirSync(datasetsDir, { recursive: true });
}

// Funci√≥n simple para generar datos
function generateSimpleDataset(scenarios = 50, hours = 240) {
    console.log(`Generando ${scenarios} escenarios con ${hours} horas cada uno`);
    
    const allData = [];
    
    for (let scenario = 1; scenario <= scenarios; scenario++) {
        // Par√°metros del escenario
        const baseTemp = 20 + Math.random() * 10;
        const basePh = 6.8 + Math.random() * 1.2;
        const maxPAR = 400 + Math.random() * 600;
        const initialBiomass = 0.05 + Math.random() * 0.3;
        
        let currentBiomass = initialBiomass;
        let currentTemp = baseTemp;
        let currentpH = basePh;
        let nutrients = 0.5 + Math.random() * 0.5;
        
        for (let hour = 0; hour < hours; hour++) {
            // Ciclo de luz simple
            const hourOfDay = hour % 24;
            const lightIntensity = (hourOfDay >= 6 && hourOfDay <= 18) ? 
                maxPAR * Math.sin((hourOfDay - 6) * Math.PI / 12) : 0;
            
            // Variaciones simples
            currentTemp = baseTemp + Math.random() * 4 - 2;
            currentpH = basePh + Math.random() * 0.4 - 0.2;
            nutrients = Math.max(0.1, nutrients - 0.001);
            
            // Crecimiento simple
            const growthRate = 0.02 * Math.random() * (lightIntensity / 500) * (nutrients / 0.5);
            currentBiomass = Math.min(currentBiomass * (1 + growthRate), 4.0);
            
            // Crear punto de datos
            const dataPoint = {
                Scenario: scenario,
                Time_h: hour,
                DateTime: new Date(Date.now() + hour * 3600000).toISOString(),
                pH: parseFloat(currentpH.toFixed(2)),
                Temperature_C: parseFloat(currentTemp.toFixed(1)),
                PAR_umol_m2_s: parseFloat(lightIntensity.toFixed(1)),
                Growth_Rate_h: parseFloat(growthRate.toFixed(4)),
                Biomass_g_L: parseFloat(currentBiomass.toFixed(3)),
                Cell_Concentration_cells_mL: parseFloat((currentBiomass * 2e6).toFixed(0)),
                Nutrients_g_L: parseFloat(nutrients.toFixed(3)),
                Optical_Density_OD680: parseFloat((currentBiomass * 2.5).toFixed(3)),
                Productivity_g_L_d: parseFloat((currentBiomass * growthRate * 24).toFixed(3)),
                Light_Efficiency: parseFloat((growthRate / Math.max(0.001, lightIntensity / 1000)).toFixed(4)),
                Thermal_Stress: currentTemp > 30 || currentTemp < 20 ? 1 : 0,
                pH_Stress: currentpH < 6.5 || currentpH > 8.0 ? 1 : 0,
                Light_Regime: 'cyclic',
                Stress_Condition: 'normal',
                Data_Quality: 'industrial',
                Sampling_Resolution: 'hour'
            };
            
            allData.push(dataPoint);
        }
        
        // Log progreso
        if (scenario % 10 === 0) {
            console.log(`Completado ${scenario}/${scenarios} escenarios`);
        }
    }
    
    return allData;
}

// Funci√≥n para convertir a CSV
function arrayToCSV(data) {
    if (!data || data.length === 0) return '';
    
    const headers = Object.keys(data[0]);
    const csvRows = [headers.join(',')];
    
    for (const row of data) {
        const values = headers.map(header => {
            const value = row[header];
            return typeof value === 'string' && value.includes(',') ? `"${value}"` : value;
        });
        csvRows.push(values.join(','));
    }
    
    return csvRows.join('\n');
}

// Funci√≥n para dividir datos
function splitData(data) {
    const shuffled = [...data].sort(() => Math.random() - 0.5);
    const trainSize = Math.floor(shuffled.length * 0.7);
    const validSize = Math.floor(shuffled.length * 0.15);
    
    return {
        training: shuffled.slice(0, trainSize),
        validation: shuffled.slice(trainSize, trainSize + validSize),
        test: shuffled.slice(trainSize + validSize)
    };
}

// Test endpoint
app.get('/test', (req, res) => {
    console.log('Test endpoint llamado');
    res.json({ 
        message: 'Servidor funcionando correctamente',
        timestamp: new Date().toISOString(),
        status: 'OK'
    });
});

// Endpoint principal
app.post('/generate-dataset', (req, res) => {
    console.log('=== INICIANDO GENERACI√ìN DE DATASET ===');
    console.log('Body recibido:', req.body);
    
    try {
        const { scenarios = 50, hoursPerScenario = 240 } = req.body;
        
        console.log(`Generando dataset con ${scenarios} escenarios y ${hoursPerScenario} horas`);
        
        // Generar datos
        const allData = generateSimpleDataset(scenarios, hoursPerScenario);
        console.log(`Datos generados: ${allData.length} registros`);
        
        // Dividir datos
        const splitDatasets = splitData(allData);
        console.log(`Datos divididos: ${splitDatasets.training.length} train, ${splitDatasets.validation.length} validation, ${splitDatasets.test.length} test`);
        
        // Crear directorio √∫nico
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const outputDir = path.join(datasetsDir, timestamp);
        fs.mkdirSync(outputDir, { recursive: true });
        
        // Guardar archivos
        fs.writeFileSync(path.join(outputDir, 'complete_dataset.csv'), arrayToCSV(allData));
        fs.writeFileSync(path.join(outputDir, 'training_data.csv'), arrayToCSV(splitDatasets.training));
        fs.writeFileSync(path.join(outputDir, 'validation_data.csv'), arrayToCSV(splitDatasets.validation));
        fs.writeFileSync(path.join(outputDir, 'test_data.csv'), arrayToCSV(splitDatasets.test));
        
        // Estad√≠sticas
        const stats = {
            totalPoints: allData.length,
            trainingPoints: splitDatasets.training.length,
            validationPoints: splitDatasets.validation.length,
            testPoints: splitDatasets.test.length,
            scenarios: scenarios,
            duration: hoursPerScenario,
            biomassRange: {
                min: Math.min(...allData.map(d => d.Biomass_g_L)),
                max: Math.max(...allData.map(d => d.Biomass_g_L)),
                mean: allData.reduce((sum, d) => sum + d.Biomass_g_L, 0) / allData.length
            },
            stressDistribution: {
                thermal: allData.filter(d => d.Thermal_Stress === 1).length,
                ph: allData.filter(d => d.pH_Stress === 1).length,
                normal: allData.filter(d => d.Thermal_Stress === 0 && d.pH_Stress === 0).length
            },
            qualityMetrics: {
                completeness: 100,
                dataQuality: 'industrial',
                resolution: 'hour'
            },
            outputDir: outputDir
        };
        
        // Guardar metadatos
        const metadata = {
            timestamp: new Date().toISOString(),
            configuration: req.body,
            statistics: stats
        };
        fs.writeFileSync(path.join(outputDir, 'metadata.json'), JSON.stringify(metadata, null, 2));
        
        console.log('=== DATASET GENERADO EXITOSAMENTE ===');
        console.log(`Archivos guardados en: ${outputDir}`);
        
        res.json({
            success: true,
            message: 'Dataset generado exitosamente',
            stats: stats,
            outputDir: outputDir,
            metadata: metadata
        });
        
    } catch (error) {
        console.error('=== ERROR GENERANDO DATASET ===');
        console.error('Error:', error);
        console.error('Stack:', error.stack);
        
        res.status(500).json({
            success: false,
            error: error.message,
            stack: error.stack
        });
    }
});

// Endpoint para obtener muestra de datos
app.get('/sample-data/:folder', (req, res) => {
    const { folder } = req.params;
    const { limit = 1000 } = req.query;
    
    console.log(`Solicitando muestra de datos: ${folder}, l√≠mite: ${limit}`);
    
    const filePath = path.join(datasetsDir, folder, 'complete_dataset.csv');
    
    if (!fs.existsSync(filePath)) {
        console.log(`Archivo no encontrado: ${filePath}`);
        return res.status(404).json({ error: 'Dataset no encontrado' });
    }
    
    try {
        const csvData = fs.readFileSync(filePath, 'utf8');
        const lines = csvData.split('\n').filter(line => line.trim());
        
        if (lines.length < 2) {
            return res.status(400).json({ error: 'Dataset vac√≠o' });
        }
        
        const headers = lines[0].split(',');
        const sampleData = [];
        const step = Math.max(1, Math.floor((lines.length - 1) / parseInt(limit)));
        
        for (let i = 1; i < lines.length && sampleData.length < parseInt(limit); i += step) {
            const line = lines[i];
            if (line.trim()) {
                const values = line.split(',');
                const dataPoint = {};
                
                headers.forEach((header, index) => {
                    let value = values[index];
                    if (value && !isNaN(value) && value !== '') {
                        value = parseFloat(value);
                    }
                    dataPoint[header.trim()] = value;
                });
                
                sampleData.push(dataPoint);
            }
        }
        
        console.log(`Muestra generada: ${sampleData.length} registros`);
        res.json(sampleData);
        
    } catch (error) {
        console.error('Error leyendo muestra:', error);
        res.status(500).json({ error: 'Error procesando datos' });
    }
});

// Endpoint para descargar archivos
app.get('/download/:folder/:filename', (req, res) => {
    const { folder, filename } = req.params;
    const filePath = path.join(datasetsDir, folder, filename);
    
    console.log(`Descarga solicitada: ${filePath}`);
    
    if (fs.existsSync(filePath)) {
        res.download(filePath, filename);
    } else {
        console.log(`Archivo no encontrado: ${filePath}`);
        res.status(404).send('Archivo no encontrado');
    }
});

// P√°gina principal
app.get('/', (req, res) => {
    const indexPath = path.join(__dirname, 'public', 'index.html');
    if (fs.existsSync(indexPath)) {
        res.sendFile(indexPath);
    } else {
        res.send(`
            <h1>Generador de Dataset Chlorella</h1>
            <p>Servidor funcionando correctamente</p>
            <p>Timestamp: ${new Date().toISOString()}</p>
            <p>El archivo index.html debe estar en la carpeta public/</p>
        `);
    }
});

// Manejo de errores
app.use((err, req, res, next) => {
    console.error('Error del servidor:', err);
    res.status(500).json({ error: 'Error interno del servidor' });
});

// Iniciar servidor
const PORT = process.env.PORT || 3000;

const server = app.listen(PORT, '0.0.0.0', () => {
    console.log('=================================');
    console.log(`‚úÖ SERVIDOR INICIADO`);
    console.log(`üåê Puerto: ${PORT}`);
    console.log(`üìÅ Directorio: ${__dirname}`);
    console.log(`üìä Datasets: ${datasetsDir}`);
    console.log(`üöÄ URL: http://localhost:${PORT}`);
    console.log('=================================');
});

server.on('error', (error) => {
    console.error('‚ùå Error del servidor:', error);
    if (error.code === 'EADDRINUSE') {
        console.error(`Puerto ${PORT} ya est√° en uso`);
    }
});

// Graceful shutdown
process.on('SIGTERM', () => {
    console.log('Cerrando servidor...');
    server.close(() => {
        console.log('Servidor cerrado');
        process.exit(0);
    });
});

console.log('Servidor configurado, esperando conexiones...');
